//å¦‚æœäº¤æ¢å­—ç¬¦ä¸² X ä¸­çš„ä¸¤ä¸ªä¸åŒä½ç½®çš„å­—æ¯ï¼Œä½¿å¾—å®ƒå’Œå­—ç¬¦ä¸² Y ç›¸ç­‰ï¼Œé‚£ä¹ˆç§° X å’Œ Y ä¸¤ä¸ªå­—ç¬¦ä¸²ç›¸ä¼¼ã€‚å¦‚æœè¿™ä¸¤ä¸ªå­—ç¬¦ä¸²æœ¬èº«æ˜¯ç›¸ç­‰çš„ï¼Œé‚£å®ƒä»¬ä¹Ÿæ˜¯ç›¸ä¼¼çš„ã€‚ 
//
//
// ä¾‹å¦‚ï¼Œ"tars" å’Œ "rats" æ˜¯ç›¸ä¼¼çš„ (äº¤æ¢ 0 ä¸ 2 çš„ä½ç½®)ï¼› "rats" å’Œ "arts" ä¹Ÿæ˜¯ç›¸ä¼¼çš„ï¼Œä½†æ˜¯ "star" ä¸ä¸ "t
//ars"ï¼Œ"rats"ï¼Œæˆ– "arts" ç›¸ä¼¼ã€‚ 
//
// æ€»ä¹‹ï¼Œå®ƒä»¬é€šè¿‡ç›¸ä¼¼æ€§å½¢æˆäº†ä¸¤ä¸ªå…³è”ç»„ï¼š{"tars", "rats", "arts"} å’Œ {"star"}ã€‚æ³¨æ„ï¼Œ"tars" å’Œ "arts" æ˜¯åœ¨åŒ
//ä¸€ç»„ä¸­ï¼Œå³ä½¿å®ƒä»¬å¹¶ä¸ç›¸ä¼¼ã€‚å½¢å¼ä¸Šï¼Œå¯¹æ¯ä¸ªç»„è€Œè¨€ï¼Œè¦ç¡®å®šä¸€ä¸ªå•è¯åœ¨ç»„ä¸­ï¼Œåªéœ€è¦è¿™ä¸ªè¯å’Œè¯¥ç»„ä¸­è‡³å°‘ä¸€ä¸ªå•è¯ç›¸ä¼¼ã€‚ 
//
// ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸²åˆ—è¡¨ strsã€‚åˆ—è¡¨ä¸­çš„æ¯ä¸ªå­—ç¬¦ä¸²éƒ½æ˜¯ strs ä¸­å…¶å®ƒæ‰€æœ‰å­—ç¬¦ä¸²çš„ä¸€ä¸ªå­—æ¯å¼‚ä½è¯ã€‚è¯·é—® strs ä¸­æœ‰å¤šå°‘ä¸ªç›¸ä¼¼å­—ç¬¦ä¸²ç»„ï¼Ÿ 
//
// 
//
// ç¤ºä¾‹ 1ï¼š 
//
// 
//è¾“å…¥ï¼šstrs = ["tars","rats","arts","star"]
//è¾“å‡ºï¼š2
// 
//
// ç¤ºä¾‹ 2ï¼š 
//
// 
//è¾“å…¥ï¼šstrs = ["omv","ovm"]
//è¾“å‡ºï¼š1
// 
//
// 
//
// æç¤ºï¼š 
//
// 
// 1 <= strs.length <= 100 
// 1 <= strs[i].length <= 1000 
// sum(strs[i].length) <= 2 * 104 
// strs[i] åªåŒ…å«å°å†™å­—æ¯ã€‚ 
// strs ä¸­çš„æ‰€æœ‰å•è¯éƒ½å…·æœ‰ç›¸åŒçš„é•¿åº¦ï¼Œä¸”æ˜¯å½¼æ­¤çš„å­—æ¯å¼‚ä½è¯ã€‚ 
// 
//
// 
//
// å¤‡æ³¨ï¼š 
//
// å­—æ¯å¼‚ä½è¯ï¼ˆanagramï¼‰ï¼Œä¸€ç§æŠŠæŸä¸ªå­—ç¬¦ä¸²çš„å­—æ¯çš„ä½ç½®ï¼ˆé¡ºåºï¼‰åŠ ä»¥æ”¹æ¢æ‰€å½¢æˆçš„æ–°è¯ã€‚ 
// Related Topics æ·±åº¦ä¼˜å…ˆæœç´¢ å¹¶æŸ¥é›† å›¾ 
// ğŸ‘ 65 ğŸ‘ 0


package com.martin.leetcode.editor.cn;


public class SimilarStringGroups{
    public static void main(String[] args) {
       Solution solution = new SimilarStringGroups().new Solution();
        System.out.println(solution.numSimilarGroups(new String[] {"tars","rats","arts","star"}));
    }
    
    //leetcode submit region begin(Prohibit modification and deletion)
/*class Solution {
    public int numSimilarGroups(String[] strs) {
        int len = strs.length;
        UnionFind unionFind = new UnionFind(len);
        for (int i = 0; i < len-1; i++) {
            for (int j = i+1; j < len; j++) {
                if (check(strs[i], strs[j])) {
                    unionFind.union(i, j);
                }
            }
        }
        return unionFind.count;
    }

    public boolean check(String a, String b) {
        if (a.equals(b)) return true;
        int num = 0;
        for (int i = 0; i < a.length(); i++) {
            if (a.charAt(i) != b.charAt(i)) {
                num++;
                if (num > 2) {
                    return false;
                }
            }
        }
        return true;
    }

*//*    public boolean check(String s1, String s2) {
        if (s1.length() != s2.length()) return false;
        if (s1.equals(s2)) return true;
        int count = 0;
        int compare = 0;
        for (int i = 0; i < s1.length(); i++) {
            char c1 = s1.charAt(i);
            char c2 = s2.charAt(i);
            if (c1 != c2) count++;

            compare ^= c1;
            compare ^= c2;

        }
        return count == 2 && compare == 0;
    }*//*

    class UnionFind {
        int[] p;
        int count;
        public UnionFind(int len) {
            p = new int[len];
            count = len;
            for (int i = 0; i < len; i++) {
                p[i] = i;
            }
        }
        public int find(int id) {
            if (p[id] != id) {
                p[id] = find(p[id]);
            }
            return p[id];
        }
        public void union(int x, int y) {
            int xRoot = find(x);
            int yRoot = find(y);
            if (xRoot != yRoot) {
                p[xRoot] = yRoot;
                count--;
            }
        }
    }
}*/
class Solution {
    public int numSimilarGroups(String[] strs) {
        int len = strs.length;
        boolean[] visited = new boolean[len];
        int ans = 0;
        for (int i = 0; i < len; i++) {
            if (visited[i]) continue;
            dfs(i, strs, visited);
            ans++;
        }
        return ans;
    }

    public void dfs(int cur, String[] strs, boolean[] visited) {
        if (!visited[cur]) {
            visited[cur] = true;
            for (int i = 0; i < strs.length; i++) {
                if (visited[i]) continue;
                if (check(strs[cur], strs[i])) {
                    dfs(i, strs, visited);
                }
            }
        }
    }

    public boolean check(String a, String b) {
        if (a.equals(b)) return true;
        int num = 0;
        for (int i = 0; i < a.length(); i++) {
            if (a.charAt(i) != b.charAt(i)) {
                num++;
                if (num > 2) {
                    return false;
                }
            }
        }
        return true;
    }
}
//leetcode submit region end(Prohibit modification and deletion)

}
